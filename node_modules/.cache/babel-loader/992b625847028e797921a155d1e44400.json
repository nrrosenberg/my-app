{"ast":null,"code":"'use strict';\n\nvar isPlainObject = require('lodash/isPlainObject');\n\nvar isFunction = require('lodash/isFunction');\n\nvar _find = require('lodash/find');\n\nvar _merge = require('lodash/merge');\n\nvar _identity = require('lodash/identity');\n\nvar _transform = require('lodash/transform');\n\nvar _mapValues = require('lodash/mapValues');\n\nvar _mapKeys = require('lodash/mapKeys');\n\nvar _pick = require('lodash/pick');\n\nvar _pickBy = require('lodash/pickBy');\n\nvar _keys = require('lodash/keys');\n\nvar _each = require('lodash/each');\n\nvar _isNil = require('lodash/isNil');\n\nvar Inflector = require('./inflector');\n\nmodule.exports = function (collectionName, record, payload, opts) {\n  function isComplexType(obj) {\n    return Array.isArray(obj) || isPlainObject(obj);\n  }\n\n  function keyForAttribute(attribute) {\n    if (isPlainObject(attribute)) {\n      return _transform(attribute, function (result, value, key) {\n        if (isComplexType(value)) {\n          result[keyForAttribute(key)] = keyForAttribute(value);\n        } else {\n          result[keyForAttribute(key)] = value;\n        }\n      });\n    } else if (Array.isArray(attribute)) {\n      return attribute.map(function (attr) {\n        if (isComplexType(attr)) {\n          return keyForAttribute(attr);\n        } else {\n          return attr;\n        }\n      });\n    } else {\n      if (isFunction(opts.keyForAttribute)) {\n        return opts.keyForAttribute(attribute);\n      } else {\n        return Inflector.caserize(attribute, opts);\n      }\n    }\n  }\n\n  function getId() {\n    return opts.id || 'id';\n  }\n\n  function getRef(current, item, opts) {\n    if (isFunction(opts.ref)) {\n      return opts.ref(current, item);\n    } else if (opts.ref === true) {\n      if (Array.isArray(item)) {\n        return item.map(function (val) {\n          return String(val);\n        });\n      } else if (item) {\n        return String(item);\n      }\n    } else if (item && item[opts.ref]) {\n      return String(item[opts.ref]);\n    }\n  }\n\n  function getType(str, attrVal) {\n    var type;\n    attrVal = attrVal || {};\n\n    if (isFunction(opts.typeForAttribute)) {\n      type = opts.typeForAttribute(str, attrVal);\n    } // If the pluralize option is on, typeForAttribute returned undefined or wasn't used\n\n\n    if ((opts.pluralizeType === undefined || opts.pluralizeType) && type === undefined) {\n      type = Inflector.pluralize(str);\n    }\n\n    if (type === undefined) {\n      type = str;\n    }\n\n    return type;\n  }\n\n  function getLinks(current, links, dest) {\n    return _mapValues(links, function (value) {\n      if (isFunction(value)) {\n        return value(record, current, dest);\n      } else {\n        return value;\n      }\n    });\n  }\n\n  function getMeta(current, meta) {\n    if (isFunction(meta)) {\n      return meta(record);\n    } else {\n      return _mapValues(meta, function (value) {\n        if (isFunction(value)) {\n          return value(record, current);\n        } else {\n          return value;\n        }\n      });\n    }\n  }\n\n  function pick(obj, attributes) {\n    return _mapKeys(_pick(obj, attributes), function (value, key) {\n      return keyForAttribute(key);\n    });\n  }\n\n  function isCompoundDocumentIncluded(included, item) {\n    return _find(payload.included, {\n      id: item.id,\n      type: item.type\n    });\n  }\n\n  function pushToIncluded(dest, include) {\n    var included = isCompoundDocumentIncluded(dest, include);\n\n    if (included) {\n      // Merge relationships\n      included.relationships = _merge(included.relationships, _pickBy(include.relationships, _identity)); // Merge attributes\n\n      included.attributes = _merge(included.attributes, _pickBy(include.attributes, _identity));\n    } else {\n      if (!dest.included) {\n        dest.included = [];\n      }\n\n      dest.included.push(include);\n    }\n  }\n\n  this.serialize = function (dest, current, attribute, opts) {\n    var that = this;\n    var data = null;\n\n    if (opts && opts.ref) {\n      if (!dest.relationships) {\n        dest.relationships = {};\n      }\n\n      if (Array.isArray(current[attribute])) {\n        data = current[attribute].map(function (item) {\n          return that.serializeRef(item, current, attribute, opts);\n        });\n      } else {\n        data = that.serializeRef(current[attribute], current, attribute, opts);\n      }\n\n      dest.relationships[keyForAttribute(attribute)] = {};\n\n      if (!opts.ignoreRelationshipData) {\n        dest.relationships[keyForAttribute(attribute)].data = data;\n      }\n\n      if (opts.relationshipLinks) {\n        var links = getLinks(current[attribute], opts.relationshipLinks, dest);\n\n        if (links.related) {\n          dest.relationships[keyForAttribute(attribute)].links = links;\n        }\n      }\n\n      if (opts.relationshipMeta) {\n        dest.relationships[keyForAttribute(attribute)].meta = getMeta(current[attribute], opts.relationshipMeta);\n      }\n    } else {\n      if (Array.isArray(current[attribute])) {\n        if (current[attribute].length && isPlainObject(current[attribute][0])) {\n          data = current[attribute].map(function (item) {\n            return that.serializeNested(item, current, attribute, opts);\n          });\n        } else {\n          data = current[attribute];\n        }\n\n        dest.attributes[keyForAttribute(attribute)] = data;\n      } else if (isPlainObject(current[attribute])) {\n        data = that.serializeNested(current[attribute], current, attribute, opts);\n        dest.attributes[keyForAttribute(attribute)] = data;\n      } else {\n        dest.attributes[keyForAttribute(attribute)] = current[attribute];\n      }\n    }\n  };\n\n  this.serializeRef = function (dest, current, attribute, opts) {\n    var that = this;\n    var id = getRef(current, dest, opts);\n    var type = getType(attribute, dest);\n    var relationships = [];\n    var includedAttrs = [];\n\n    if (opts.attributes) {\n      if (dest) {\n        opts.attributes.forEach(function (attr) {\n          if (opts[attr] && !dest[attr] && opts[attr].nullIfMissing) {\n            dest[attr] = null;\n          }\n        });\n      }\n\n      relationships = opts.attributes.filter(function (attr) {\n        return opts[attr];\n      });\n      includedAttrs = opts.attributes.filter(function (attr) {\n        return !opts[attr];\n      });\n    }\n\n    var included = {\n      type: type,\n      id: id\n    };\n\n    if (includedAttrs) {\n      included.attributes = pick(dest, includedAttrs);\n    }\n\n    relationships.forEach(function (relationship) {\n      if (dest && (isComplexType(dest[relationship]) || dest[relationship] === null)) {\n        that.serialize(included, dest, relationship, opts[relationship]);\n      }\n    });\n\n    if (includedAttrs.length && (opts.included === undefined || opts.included)) {\n      if (opts.includedLinks) {\n        included.links = getLinks(dest, opts.includedLinks);\n      }\n\n      if (typeof id !== 'undefined') {\n        pushToIncluded(payload, included);\n      }\n    }\n\n    return typeof id !== 'undefined' ? {\n      type: type,\n      id: id\n    } : null;\n  };\n\n  this.serializeNested = function (dest, current, attribute, opts) {\n    var that = this;\n    var embeds = [];\n    var attributes = [];\n\n    if (opts && opts.attributes) {\n      embeds = opts.attributes.filter(function (attr) {\n        return opts[attr];\n      });\n      attributes = opts.attributes.filter(function (attr) {\n        return !opts[attr];\n      });\n    } else {\n      attributes = _keys(dest);\n    }\n\n    var ret = {};\n\n    if (attributes) {\n      ret.attributes = pick(dest, attributes);\n    }\n\n    embeds.forEach(function (embed) {\n      if (isComplexType(dest[embed])) {\n        that.serialize(ret, dest, embed, opts[embed]);\n      }\n    });\n    return ret.attributes;\n  };\n\n  this.perform = function () {\n    var that = this;\n\n    if (record === null) {\n      return null;\n    } // If option is present, transform record\n\n\n    if (opts && opts.transform) {\n      record = opts.transform(record);\n    } // Top-level data.\n\n\n    var data = {\n      type: getType(collectionName, record)\n    };\n\n    if (!_isNil(record[getId()])) {\n      data.id = String(record[getId()]);\n    } // Data links.\n\n\n    if (opts.dataLinks) {\n      data.links = getLinks(record, opts.dataLinks);\n    } // Data meta\n\n\n    if (opts.dataMeta) {\n      data.meta = getMeta(record, opts.dataMeta);\n    }\n\n    _each(opts.attributes, function (attribute) {\n      var splittedAttributes = attribute.split(':');\n\n      if (opts[attribute] && !record[attribute] && opts[attribute].nullIfMissing) {\n        record[attribute] = null;\n      }\n\n      if (splittedAttributes[0] in record) {\n        if (!data.attributes) {\n          data.attributes = {};\n        }\n\n        var attributeMap = attribute;\n\n        if (splittedAttributes.length > 1) {\n          attribute = splittedAttributes[0];\n          attributeMap = splittedAttributes[1];\n        }\n\n        that.serialize(data, record, attribute, opts[attributeMap]);\n      }\n    });\n\n    return data;\n  };\n};","map":{"version":3,"sources":["/Users/nicorosenberg/Desktop/grupo-belicooo/my-app/node_modules/jsonapi-serializer/lib/serializer-utils.js"],"names":["isPlainObject","require","isFunction","_find","_merge","_identity","_transform","_mapValues","_mapKeys","_pick","_pickBy","_keys","_each","_isNil","Inflector","module","exports","collectionName","record","payload","opts","isComplexType","obj","Array","isArray","keyForAttribute","attribute","result","value","key","map","attr","caserize","getId","id","getRef","current","item","ref","val","String","getType","str","attrVal","type","typeForAttribute","pluralizeType","undefined","pluralize","getLinks","links","dest","getMeta","meta","pick","attributes","isCompoundDocumentIncluded","included","pushToIncluded","include","relationships","push","serialize","that","data","serializeRef","ignoreRelationshipData","relationshipLinks","related","relationshipMeta","length","serializeNested","includedAttrs","forEach","nullIfMissing","filter","relationship","includedLinks","embeds","ret","embed","perform","transform","dataLinks","dataMeta","splittedAttributes","split","attributeMap"],"mappings":"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","sourcesContent":["'use strict';\nvar isPlainObject = require('lodash/isPlainObject');\nvar isFunction = require('lodash/isFunction');\nvar _find = require('lodash/find');\nvar _merge = require('lodash/merge');\nvar _identity = require('lodash/identity');\nvar _transform = require('lodash/transform');\nvar _mapValues = require('lodash/mapValues');\nvar _mapKeys = require('lodash/mapKeys');\nvar _pick = require('lodash/pick');\nvar _pickBy = require('lodash/pickBy');\nvar _keys = require('lodash/keys');\nvar _each = require('lodash/each');\nvar _isNil = require('lodash/isNil');\nvar Inflector = require('./inflector');\n\nmodule.exports = function (collectionName, record, payload, opts) {\n  function isComplexType(obj) {\n    return Array.isArray(obj) || isPlainObject(obj);\n  }\n\n  function keyForAttribute(attribute) {\n    if (isPlainObject(attribute)) {\n      return _transform(attribute, function (result, value, key) {\n        if (isComplexType(value)) {\n          result[keyForAttribute(key)] = keyForAttribute(value);\n        } else {\n          result[keyForAttribute(key)] = value;\n        }\n      });\n    } else if (Array.isArray(attribute)) {\n      return attribute.map(function (attr) {\n        if (isComplexType(attr)) {\n          return keyForAttribute(attr);\n        } else {\n          return attr;\n        }\n      });\n    } else {\n      if (isFunction(opts.keyForAttribute)) {\n        return opts.keyForAttribute(attribute);\n      } else {\n        return Inflector.caserize(attribute, opts);\n      }\n    }\n  }\n\n  function getId() {\n    return opts.id || 'id';\n  }\n\n  function getRef(current, item, opts) {\n    if (isFunction(opts.ref)) {\n      return opts.ref(current, item);\n    } else if (opts.ref === true) {\n      if (Array.isArray(item)) {\n        return item.map(function (val) {\n          return String(val);\n        });\n      } else if (item) {\n        return String(item);\n      }\n    } else if (item && item[opts.ref]){\n      return String(item[opts.ref]);\n    }\n  }\n\n  function getType(str, attrVal) {\n    var type;\n    attrVal = attrVal || {};\n\n    if (isFunction(opts.typeForAttribute)) {\n      type = opts.typeForAttribute(str, attrVal);\n    }\n\n    // If the pluralize option is on, typeForAttribute returned undefined or wasn't used\n    if ((opts.pluralizeType === undefined || opts.pluralizeType) && type === undefined) {\n      type = Inflector.pluralize(str);\n    }\n\n    if (type === undefined) {\n      type = str;\n    }\n\n    return type;\n  }\n\n  function getLinks(current, links, dest) {\n    return _mapValues(links, function (value) {\n      if (isFunction(value)) {\n        return value(record, current, dest);\n      } else {\n        return value;\n      }\n    });\n  }\n\n  function getMeta(current, meta) {\n    if (isFunction(meta)) {\n        return meta(record);\n    } else {\n      return _mapValues(meta, function (value) {\n        if (isFunction(value)) {\n          return value(record, current);\n        } else {\n          return value;\n        }\n      });\n    }\n  }\n\n  function pick(obj, attributes) {\n    return _mapKeys(_pick(obj, attributes), function (value, key) {\n      return keyForAttribute(key);\n    });\n  }\n\n  function isCompoundDocumentIncluded(included, item) {\n    return _find(payload.included, { id: item.id, type: item.type });\n  }\n\n  function pushToIncluded(dest, include) {\n    var included = isCompoundDocumentIncluded(dest, include);\n    if (included) {\n      // Merge relationships\n      included.relationships = _merge(included.relationships,\n        _pickBy(include.relationships, _identity));\n\n      // Merge attributes\n      included.attributes = _merge(included.attributes,\n        _pickBy(include.attributes, _identity));\n    } else {\n      if (!dest.included) { dest.included = []; }\n      dest.included.push(include);\n    }\n  }\n\n  this.serialize = function (dest, current, attribute, opts) {\n    var that = this;\n    var data = null;\n\n    if (opts && opts.ref) {\n      if (!dest.relationships) { dest.relationships = {}; }\n\n      if (Array.isArray(current[attribute])) {\n        data = current[attribute].map(function (item) {\n          return that.serializeRef(item, current, attribute, opts);\n        });\n      } else {\n        data = that.serializeRef(current[attribute], current, attribute,\n          opts);\n      }\n\n      dest.relationships[keyForAttribute(attribute)] = {};\n      if (!opts.ignoreRelationshipData) {\n        dest.relationships[keyForAttribute(attribute)].data = data;\n      }\n\n      if (opts.relationshipLinks) {\n        var links = getLinks(current[attribute], opts.relationshipLinks, dest);\n        if (links.related) {\n          dest.relationships[keyForAttribute(attribute)].links = links;\n        }\n      }\n\n      if (opts.relationshipMeta) {\n        dest.relationships[keyForAttribute(attribute)].meta =\n          getMeta(current[attribute], opts.relationshipMeta);\n      }\n    } else {\n      if (Array.isArray(current[attribute])) {\n        if (current[attribute].length && isPlainObject(current[attribute][0])) {\n          data = current[attribute].map(function (item) {\n            return that.serializeNested(item, current, attribute, opts);\n          });\n        } else {\n          data = current[attribute];\n        }\n\n        dest.attributes[keyForAttribute(attribute)] = data;\n      } else if (isPlainObject(current[attribute])) {\n        data = that.serializeNested(current[attribute], current, attribute, opts);\n        dest.attributes[keyForAttribute(attribute)] = data;\n      } else {\n        dest.attributes[keyForAttribute(attribute)] = current[attribute];\n      }\n    }\n  };\n\n  this.serializeRef = function (dest, current, attribute, opts) {\n    var that = this;\n    var id = getRef(current, dest, opts);\n    var type = getType(attribute, dest);\n\n    var relationships = [];\n    var includedAttrs = [];\n\n    if (opts.attributes) {\n      if (dest) {\n        opts.attributes.forEach(function (attr) {\n          if (opts[attr] && !dest[attr] && opts[attr].nullIfMissing) {\n            dest[attr] = null;\n          }\n        });\n      }\n      relationships = opts.attributes.filter(function (attr) {\n        return opts[attr];\n      });\n\n      includedAttrs = opts.attributes.filter(function (attr) {\n        return !opts[attr];\n      });\n    }\n\n    var included = { type: type, id: id };\n    if (includedAttrs) { included.attributes = pick(dest, includedAttrs); }\n\n    relationships.forEach(function (relationship) {\n      if (dest && (isComplexType(dest[relationship]) || dest[relationship] === null)) {\n        that.serialize(included, dest, relationship, opts[relationship]);\n      }\n    });\n\n    if (includedAttrs.length &&\n      (opts.included === undefined || opts.included)) {\n      if (opts.includedLinks) {\n        included.links = getLinks(dest, opts.includedLinks);\n      }\n\n      if (typeof id !== 'undefined') { pushToIncluded(payload, included); }\n    }\n\n    return typeof id !== 'undefined' ? { type: type, id: id } : null;\n  };\n\n  this.serializeNested = function (dest, current, attribute, opts) {\n    var that = this;\n\n    var embeds = [];\n    var attributes = [];\n\n    if (opts && opts.attributes) {\n      embeds = opts.attributes.filter(function (attr) {\n        return opts[attr];\n      });\n\n      attributes = opts.attributes.filter(function (attr) {\n        return !opts[attr];\n      });\n    } else {\n      attributes = _keys(dest);\n    }\n\n    var ret = {};\n    if (attributes) { ret.attributes = pick(dest, attributes); }\n\n    embeds.forEach(function (embed) {\n      if (isComplexType(dest[embed])) {\n        that.serialize(ret, dest, embed, opts[embed]);\n      }\n    });\n\n    return ret.attributes;\n  };\n\n  this.perform = function () {\n    var that = this;\n\n    if( record === null ){\n        return null;\n    }\n\n    // If option is present, transform record\n    if (opts && opts.transform) {\n      record = opts.transform(record);\n    }\n\n    // Top-level data.\n    var data = { type: getType(collectionName, record) };\n    if (!_isNil(record[getId()])) { data.id = String(record[getId()]); }\n\n    // Data links.\n    if (opts.dataLinks) {\n      data.links = getLinks(record, opts.dataLinks);\n    }\n\n    // Data meta\n    if (opts.dataMeta) {\n      data.meta = getMeta(record, opts.dataMeta);\n    }\n\n    _each(opts.attributes, function (attribute) {\n      var splittedAttributes = attribute.split(':');\n\n      if (opts[attribute] && !record[attribute] && opts[attribute].nullIfMissing) {\n        record[attribute] = null;\n      }\n\n      if (splittedAttributes[0] in record) {\n        if (!data.attributes) { data.attributes = {}; }\n\n        var attributeMap = attribute;\n        if (splittedAttributes.length > 1) {\n          attribute = splittedAttributes[0];\n          attributeMap = splittedAttributes[1];\n        }\n\n        that.serialize(data, record, attribute, opts[attributeMap]);\n      }\n    });\n\n    return data;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}