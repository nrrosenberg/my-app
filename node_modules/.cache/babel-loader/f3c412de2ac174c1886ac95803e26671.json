{"ast":null,"code":"'use strict';\n\nvar isPlainObject = require('lodash/isPlainObject');\n\nvar isFunction = require('lodash/isFunction');\n\nvar _find = require('lodash/find');\n\nvar _extend = require('lodash/extend');\n\nvar _transform = require('lodash/transform');\n\nvar Inflector = require('./inflector');\n\nmodule.exports = function (jsonapi, data, opts) {\n  var alreadyIncluded = [];\n\n  function isComplexType(obj) {\n    return Array.isArray(obj) || isPlainObject(obj);\n  }\n\n  function getValueForRelationship(relationshipData, included) {\n    if (opts && relationshipData && opts[relationshipData.type]) {\n      var valueForRelationshipFct = opts[relationshipData.type].valueForRelationship;\n      return valueForRelationshipFct(relationshipData, included);\n    } else {\n      return included;\n    }\n  }\n\n  function findIncluded(relationshipData, ancestry) {\n    return new Promise(function (resolve) {\n      if (!jsonapi.included || !relationshipData) {\n        resolve(null);\n      }\n\n      var included = _find(jsonapi.included, {\n        id: relationshipData.id,\n        type: relationshipData.type\n      });\n\n      if (included) {\n        // To prevent circular references, check if the record type\n        // has already been processed in this thread\n        if (ancestry.indexOf(included.type) > -1) {\n          return Promise.all([extractAttributes(included)]).then(function (results) {\n            var attributes = results[0];\n            var relationships = results[1];\n            resolve(_extend(attributes, relationships));\n          });\n        }\n\n        return Promise.all([extractAttributes(included), extractRelationships(included, ancestry + ':' + included.type + included.id)]).then(function (results) {\n          var attributes = results[0];\n          var relationships = results[1];\n          resolve(_extend(attributes, relationships));\n        });\n      } else {\n        return resolve(null);\n      }\n    });\n  }\n\n  function keyForAttribute(attribute) {\n    if (isPlainObject(attribute)) {\n      return _transform(attribute, function (result, value, key) {\n        if (isComplexType(value)) {\n          result[keyForAttribute(key)] = keyForAttribute(value);\n        } else {\n          result[keyForAttribute(key)] = value;\n        }\n      });\n    } else if (Array.isArray(attribute)) {\n      return attribute.map(function (attr) {\n        if (isComplexType(attr)) {\n          return keyForAttribute(attr);\n        } else {\n          return attr;\n        }\n      });\n    } else {\n      if (isFunction(opts.keyForAttribute)) {\n        return opts.keyForAttribute(attribute);\n      } else {\n        return Inflector.caserize(attribute, opts);\n      }\n    }\n  }\n\n  function extractAttributes(from) {\n    var dest = keyForAttribute(from.attributes || {});\n\n    if ('id' in from) {\n      dest[opts.id || 'id'] = from.id;\n    }\n\n    if (opts.typeAsAttribute) {\n      if ('type' in from) {\n        dest.type = from.type;\n      }\n    }\n\n    if ('meta' in from) {\n      dest.meta = keyForAttribute(from.meta || {});\n    }\n\n    return dest;\n  }\n\n  function extractRelationships(from, ancestry) {\n    if (!from.relationships) {\n      return;\n    }\n\n    var dest = {};\n    return Promise.all(Object.keys(from.relationships).map(function (key) {\n      var relationship = from.relationships[key];\n\n      if (relationship.data === null) {\n        dest[keyForAttribute(key)] = null;\n      } else if (Array.isArray(relationship.data)) {\n        return Promise.all(relationship.data.map(function (relationshipData) {\n          return extractIncludes(relationshipData, ancestry);\n        })).then(function (includes) {\n          if (includes) {\n            dest[keyForAttribute(key)] = includes;\n          }\n        });\n      } else {\n        return extractIncludes(relationship.data, ancestry).then(function (includes) {\n          if (includes) {\n            dest[keyForAttribute(key)] = includes;\n          }\n        });\n      }\n    })).then(function () {\n      return dest;\n    });\n  }\n\n  function extractIncludes(relationshipData, ancestry) {\n    return findIncluded(relationshipData, ancestry).then(function (included) {\n      var valueForRelationship = getValueForRelationship(relationshipData, included);\n\n      if (valueForRelationship && isFunction(valueForRelationship.then)) {\n        return valueForRelationship.then(function (value) {\n          return value;\n        });\n      } else {\n        return valueForRelationship;\n      }\n    });\n  }\n\n  this.perform = function () {\n    return Promise.all([extractAttributes(data), extractRelationships(data, data.type + data.id)]).then(function (results) {\n      var attributes = results[0];\n      var relationships = results[1];\n\n      var record = _extend(attributes, relationships); // Links\n\n\n      if (jsonapi.links) {\n        record.links = jsonapi.links;\n      } // If option is present, transform record\n\n\n      if (opts && opts.transform) {\n        record = opts.transform(record);\n      }\n\n      return record;\n    });\n  };\n};","map":{"version":3,"sources":["/Users/nicorosenberg/Desktop/grupo-belicooo/my-app/node_modules/jsonapi-serializer/lib/deserializer-utils.js"],"names":["isPlainObject","require","isFunction","_find","_extend","_transform","Inflector","module","exports","jsonapi","data","opts","alreadyIncluded","isComplexType","obj","Array","isArray","getValueForRelationship","relationshipData","included","type","valueForRelationshipFct","valueForRelationship","findIncluded","ancestry","Promise","resolve","id","indexOf","all","extractAttributes","then","results","attributes","relationships","extractRelationships","keyForAttribute","attribute","result","value","key","map","attr","caserize","from","dest","typeAsAttribute","meta","Object","keys","relationship","extractIncludes","includes","perform","record","links","transform"],"mappings":"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","sourcesContent":["'use strict';\nvar isPlainObject = require('lodash/isPlainObject');\nvar isFunction = require('lodash/isFunction');\nvar _find = require('lodash/find');\nvar _extend = require('lodash/extend');\nvar _transform = require('lodash/transform');\nvar Inflector = require('./inflector');\n\nmodule.exports = function (jsonapi, data, opts) {\n  var alreadyIncluded = [];\n\n  function isComplexType(obj) {\n    return Array.isArray(obj) || isPlainObject(obj);\n  }\n\n  function getValueForRelationship(relationshipData, included) {\n    if (opts && relationshipData && opts[relationshipData.type]) {\n      var valueForRelationshipFct = opts[relationshipData.type]\n        .valueForRelationship;\n\n      return valueForRelationshipFct(relationshipData, included);\n    } else {\n      return included;\n    }\n  }\n\n  function findIncluded(relationshipData, ancestry) {\n    return new Promise(function (resolve) {\n      if (!jsonapi.included || !relationshipData) { resolve(null); }\n\n      var included = _find(jsonapi.included, {\n        id: relationshipData.id,\n        type: relationshipData.type\n      });\n\n      if (included) {\n        // To prevent circular references, check if the record type\n        // has already been processed in this thread\n        if (ancestry.indexOf(included.type) > -1) {\n          return Promise\n            .all([extractAttributes(included)])\n            .then(function (results) {\n              var attributes = results[0];\n              var relationships = results[1];\n              resolve(_extend(attributes, relationships));\n            });\n        }\n\n        return Promise\n          .all([extractAttributes(included), extractRelationships(included, ancestry + ':' + included.type + included.id)])\n          .then(function (results) {\n            var attributes = results[0];\n            var relationships = results[1];\n            resolve(_extend(attributes, relationships));\n          });\n      } else {\n        return resolve(null);\n      }\n    });\n  }\n\n  function keyForAttribute(attribute) {\n    if (isPlainObject(attribute)) {\n      return _transform(attribute, function (result, value, key) {\n        if (isComplexType(value)) {\n          result[keyForAttribute(key)] = keyForAttribute(value);\n        } else {\n          result[keyForAttribute(key)] = value;\n        }\n      });\n    } else if (Array.isArray(attribute)) {\n      return attribute.map(function (attr) {\n        if (isComplexType(attr)) {\n          return keyForAttribute(attr);\n        } else {\n          return attr;\n        }\n      });\n    } else {\n      if (isFunction(opts.keyForAttribute)) {\n        return opts.keyForAttribute(attribute);\n      } else {\n        return Inflector.caserize(attribute, opts);\n      }\n    }\n  }\n\n  function extractAttributes(from) {\n    var dest = keyForAttribute(from.attributes || {});\n    if ('id' in from) { dest[opts.id || 'id'] = from.id; }\n\n    if (opts.typeAsAttribute) {\n      if ('type' in from) { dest.type = from.type; }\n    }\n    if ('meta' in from) { dest.meta = keyForAttribute(from.meta || {}) }\n\n    return dest;\n  }\n\n  function extractRelationships(from, ancestry) {\n    if (!from.relationships) { return; }\n\n    var dest = {};\n\n    return Promise\n      .all(Object.keys(from.relationships).map(function (key) {\n        var relationship = from.relationships[key];\n\n        if (relationship.data === null) {\n          dest[keyForAttribute(key)] = null;\n        } else if (Array.isArray(relationship.data)) {\n          return Promise\n            .all(relationship.data.map(function (relationshipData) {\n              return extractIncludes(relationshipData, ancestry);\n            }))\n            .then(function (includes) {\n              if (includes) { dest[keyForAttribute(key)] = includes; }\n            });\n        } else {\n          return extractIncludes(relationship.data, ancestry)\n            .then(function (includes) {\n              if (includes) { dest[keyForAttribute(key)] = includes; }\n            });\n        }\n      }))\n      .then(function() {\n        return dest;\n      });\n  }\n\n  function extractIncludes(relationshipData, ancestry) {\n    return findIncluded(relationshipData, ancestry)\n      .then(function (included) {\n        var valueForRelationship = getValueForRelationship(relationshipData,\n          included);\n\n        if (valueForRelationship && isFunction(valueForRelationship.then)) {\n          return valueForRelationship.then(function (value) {\n            return value;\n          });\n        } else {\n          return valueForRelationship;\n        }\n      });\n  }\n\n  this.perform = function () {\n    return Promise\n      .all([extractAttributes(data), extractRelationships(data, data.type + data.id)])\n      .then(function (results) {\n        var attributes = results[0];\n        var relationships = results[1];\n        var record = _extend(attributes, relationships);\n\n        // Links\n        if (jsonapi.links) {\n          record.links = jsonapi.links;\n        }\n\n        // If option is present, transform record\n        if (opts && opts.transform) {\n          record = opts.transform(record);\n        }\n\n        return record;\n      });\n  };\n};\n"]},"metadata":{},"sourceType":"script"}